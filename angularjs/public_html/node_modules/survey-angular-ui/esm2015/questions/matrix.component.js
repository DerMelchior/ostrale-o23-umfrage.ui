import { Component } from "@angular/core";
import { QuestionAngular } from "../question";
import { AngularComponentFactory } from "../component-factory";
import * as i0 from "@angular/core";
import * as i1 from "../survey-string.component";
import * as i2 from "@angular/common";
import * as i3 from "../utils/dynamic.directive";
import * as i4 from "../utils/ng-show.directive";
export class MatrixQuestionComponent extends QuestionAngular {
    ngOnInit() {
        this.model.visibleRowsChangedCallback = () => {
            this.detectChanges();
        };
        super.ngOnInit();
    }
    onChange(row, column) {
        if (this.model.isInputReadOnly)
            return;
        row.value = column.value;
        this.detectChanges();
    }
    trackRowByFn(i, row) {
        return "column-" + row.name + "-" + i;
    }
    trackColumnByFn(i, column) {
        return "column-" + column.value + "-" + i;
    }
}
MatrixQuestionComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: MatrixQuestionComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
MatrixQuestionComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: MatrixQuestionComponent, selector: "sv-ng-matrix-question", usesInheritance: true, ngImport: i0, template: "<ng-template #template>\n  <div [class]=\"model.cssClasses.tableWrapper\" #contentElement>\n    <fieldset>\n      <legend [attr.aria-label]=\"model.locTitle.renderedHtml\"></legend>\n      <table [class]=\"model.getTableCss()\">\n        <thead *ngIf=\"model.showHeader\">\n          <tr>\n            <td *ngIf=\"model.hasRows\"></td>\n            <th\n              *ngFor=\"let column of model.visibleColumns\" [style]=\"{ minWidth: model.columnMinWidth, width: model.columnMinWidth }\" [class]=\"model.cssClasses.headerCell\">\n              <ng-template [component]=\"{ name: model.getColumnHeaderWrapperComponentName(column), data: { componentData: model.getColumnHeaderWrapperComponentData(column) } }\">\n                <sv-ng-string [model]=\"column.locText\"></sv-ng-string>\n              </ng-template>\n            </th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr *ngFor=\"let row of model.visibleRows; trackBy: trackRowByFn \" [class]=\"row.rowClasses || undefined\">\n           <td [class]=\"model.cssClasses.rowTextCell\" [style]=\"{ minWidth: model.rowTitleWidth, width: model.rowTitleWidth }\" *ngIf=\"model.hasRows\">\n              <ng-template [component]=\"{ name: model.getRowHeaderWrapperComponentName($any(row)), data: { componentData: model.getRowHeaderWrapperComponentData($any(row)) } }\">\n                <sv-ng-string [model]=\"row.locText\"></sv-ng-string>\n              </ng-template>\n            </td>\n            <ng-container *ngIf=\"model.hasCellText\">\n              <td *ngFor=\"let column of model.visibleColumns\"\n                [class]=\"model.getItemClass(row, column)\"\n                (click)=\"onChange(row, column)\" [model]=\"model.getCellDisplayLocText(row.name, column)\" sv-ng-string>\n              </td>\n            </ng-container>\n            <ng-container *ngIf=\"!model.hasCellText\">\n              <td\n              *ngFor=\"let column of model.visibleColumns; index as columnIndex; trackBy: trackColumnByFn\"\n              [attr.data-responsive-title]=\"column.locText.renderedHtml\"\n              [class]=\"model.cssClasses.cell\">\n                <label (mousedown)=\"model.onMouseDown()\" [class]=\"model.getItemClass(row, column)\">\n                  <input\n                    type=\"radio\"\n                    [class]=\"model.cssClasses.itemValue\"\n                    [name]=\"row.fullName\"\n                    [value]=\"column.value\"\n                    [checked]=\"row.value === column.value\"\n                    [disabled]=\"model.isInputReadOnly\"\n                    [attr.id]=\"model.inputId + '_' + row.name + '_' + columnIndex\"\n                    (change)=\"onChange(row, column)\"\n                    [attr.aria-required]=\"model.ariaRequired\"\n                    [attr.aria-label]=\"column.locText.renderedHtml\"\n                    [attr.aria-invalid]=\"model.ariaInvalid\"\n                    [attr.aria-describedby]=\"model.ariaDescribedBy\"\n                  />\n                  <span [class]=\"model.cssClasses.materialDecorator\">\n                    <svg *ngIf=\"model.itemSvgIcon\" [class]=\"model.cssClasses.itemDecorator\">\n                      <use [attr.xlink:href]=\"model.itemSvgIcon\"></use>\n                    </svg> \n                  </span>\n                  <span [visible]=\"model.isMobile\" [class]=\"model.cssClasses.cellResponsiveTitle\" [model]=\"column.locText\" sv-ng-string></span>\n                </label>\n              </td>\n            </ng-container>\n          </tr>\n        </tbody>\n      </table>\n    </fieldset>\n  </div>\n</ng-template>", styles: [":host{display:none}\n"], components: [{ type: i1.SurveyStringComponent, selector: "sv-ng-string, '[sv-ng-string]'", inputs: ["model"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.DynamicComponentDirective, selector: "[component]", inputs: ["component"] }, { type: i4.VisibleDirective, selector: "[visible]", inputs: ["visible"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: MatrixQuestionComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "sv-ng-matrix-question",
                    templateUrl: "./matrix.component.html",
                    styleUrls: ["../hide-host.scss"]
                }]
        }] });
AngularComponentFactory.Instance.registerComponent("matrix-question", MatrixQuestionComponent);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0cml4LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9xdWVzdGlvbnMvbWF0cml4LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uL3NyYy9xdWVzdGlvbnMvbWF0cml4LmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDMUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUU5QyxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQzs7Ozs7O0FBTy9ELE1BQU0sT0FBTyx1QkFBd0IsU0FBUSxlQUFvQztJQUN0RSxRQUFRO1FBQ2YsSUFBSSxDQUFDLEtBQUssQ0FBQywwQkFBMEIsR0FBRyxHQUFHLEVBQUU7WUFDM0MsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3ZCLENBQUMsQ0FBQztRQUNGLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNuQixDQUFDO0lBQ00sUUFBUSxDQUFDLEdBQVEsRUFBRSxNQUFXO1FBQ25DLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlO1lBQUUsT0FBTztRQUN2QyxHQUFHLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUM7UUFDekIsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQ3ZCLENBQUM7SUFDRCxZQUFZLENBQUMsQ0FBUyxFQUFFLEdBQVE7UUFDOUIsT0FBTyxTQUFTLEdBQUcsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFDRCxlQUFlLENBQUMsQ0FBUyxFQUFFLE1BQVc7UUFDcEMsT0FBTyxTQUFTLEdBQUcsTUFBTSxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQzVDLENBQUM7O3FIQWpCVSx1QkFBdUI7eUdBQXZCLHVCQUF1QixvRkNWcEMsMGlIQStEYzs0RkRyREQsdUJBQXVCO2tCQUxuQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSx1QkFBdUI7b0JBQ2pDLFdBQVcsRUFBRSx5QkFBeUI7b0JBQ3RDLFNBQVMsRUFBRSxDQUFDLG1CQUFtQixDQUFDO2lCQUNqQzs7QUFxQkQsdUJBQXVCLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLGlCQUFpQixFQUFFLHVCQUF1QixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgUXVlc3Rpb25Bbmd1bGFyIH0gZnJvbSBcIi4uL3F1ZXN0aW9uXCI7XG5pbXBvcnQgeyBRdWVzdGlvbk1hdHJpeE1vZGVsIH0gZnJvbSBcInN1cnZleS1jb3JlXCI7XG5pbXBvcnQgeyBBbmd1bGFyQ29tcG9uZW50RmFjdG9yeSB9IGZyb20gXCIuLi9jb21wb25lbnQtZmFjdG9yeVwiO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6IFwic3YtbmctbWF0cml4LXF1ZXN0aW9uXCIsXG4gIHRlbXBsYXRlVXJsOiBcIi4vbWF0cml4LmNvbXBvbmVudC5odG1sXCIsXG4gIHN0eWxlVXJsczogW1wiLi4vaGlkZS1ob3N0LnNjc3NcIl1cbn0pXG5leHBvcnQgY2xhc3MgTWF0cml4UXVlc3Rpb25Db21wb25lbnQgZXh0ZW5kcyBRdWVzdGlvbkFuZ3VsYXI8UXVlc3Rpb25NYXRyaXhNb2RlbD4ge1xuICBvdmVycmlkZSBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLm1vZGVsLnZpc2libGVSb3dzQ2hhbmdlZENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfTtcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xuICB9XG4gIHB1YmxpYyBvbkNoYW5nZShyb3c6IGFueSwgY29sdW1uOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5tb2RlbC5pc0lucHV0UmVhZE9ubHkpIHJldHVybjtcbiAgICByb3cudmFsdWUgPSBjb2x1bW4udmFsdWU7XG4gICAgdGhpcy5kZXRlY3RDaGFuZ2VzKCk7XG4gIH1cbiAgdHJhY2tSb3dCeUZuKGk6IG51bWJlciwgcm93OiBhbnkpOiBzdHJpbmcge1xuICAgIHJldHVybiBcImNvbHVtbi1cIiArIHJvdy5uYW1lICsgXCItXCIgKyBpO1xuICB9XG4gIHRyYWNrQ29sdW1uQnlGbihpOiBudW1iZXIsIGNvbHVtbjogYW55KTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJjb2x1bW4tXCIgKyBjb2x1bW4udmFsdWUgKyBcIi1cIiArIGk7XG4gIH1cbn1cblxuQW5ndWxhckNvbXBvbmVudEZhY3RvcnkuSW5zdGFuY2UucmVnaXN0ZXJDb21wb25lbnQoXCJtYXRyaXgtcXVlc3Rpb25cIiwgTWF0cml4UXVlc3Rpb25Db21wb25lbnQpOyIsIjxuZy10ZW1wbGF0ZSAjdGVtcGxhdGU+XG4gIDxkaXYgW2NsYXNzXT1cIm1vZGVsLmNzc0NsYXNzZXMudGFibGVXcmFwcGVyXCIgI2NvbnRlbnRFbGVtZW50PlxuICAgIDxmaWVsZHNldD5cbiAgICAgIDxsZWdlbmQgW2F0dHIuYXJpYS1sYWJlbF09XCJtb2RlbC5sb2NUaXRsZS5yZW5kZXJlZEh0bWxcIj48L2xlZ2VuZD5cbiAgICAgIDx0YWJsZSBbY2xhc3NdPVwibW9kZWwuZ2V0VGFibGVDc3MoKVwiPlxuICAgICAgICA8dGhlYWQgKm5nSWY9XCJtb2RlbC5zaG93SGVhZGVyXCI+XG4gICAgICAgICAgPHRyPlxuICAgICAgICAgICAgPHRkICpuZ0lmPVwibW9kZWwuaGFzUm93c1wiPjwvdGQ+XG4gICAgICAgICAgICA8dGhcbiAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBtb2RlbC52aXNpYmxlQ29sdW1uc1wiIFtzdHlsZV09XCJ7IG1pbldpZHRoOiBtb2RlbC5jb2x1bW5NaW5XaWR0aCwgd2lkdGg6IG1vZGVsLmNvbHVtbk1pbldpZHRoIH1cIiBbY2xhc3NdPVwibW9kZWwuY3NzQ2xhc3Nlcy5oZWFkZXJDZWxsXCI+XG4gICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbY29tcG9uZW50XT1cInsgbmFtZTogbW9kZWwuZ2V0Q29sdW1uSGVhZGVyV3JhcHBlckNvbXBvbmVudE5hbWUoY29sdW1uKSwgZGF0YTogeyBjb21wb25lbnREYXRhOiBtb2RlbC5nZXRDb2x1bW5IZWFkZXJXcmFwcGVyQ29tcG9uZW50RGF0YShjb2x1bW4pIH0gfVwiPlxuICAgICAgICAgICAgICAgIDxzdi1uZy1zdHJpbmcgW21vZGVsXT1cImNvbHVtbi5sb2NUZXh0XCI+PC9zdi1uZy1zdHJpbmc+XG4gICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L3RoPlxuICAgICAgICAgIDwvdHI+XG4gICAgICAgIDwvdGhlYWQ+XG4gICAgICAgIDx0Ym9keT5cbiAgICAgICAgICA8dHIgKm5nRm9yPVwibGV0IHJvdyBvZiBtb2RlbC52aXNpYmxlUm93czsgdHJhY2tCeTogdHJhY2tSb3dCeUZuIFwiIFtjbGFzc109XCJyb3cucm93Q2xhc3NlcyB8fCB1bmRlZmluZWRcIj5cbiAgICAgICAgICAgPHRkIFtjbGFzc109XCJtb2RlbC5jc3NDbGFzc2VzLnJvd1RleHRDZWxsXCIgW3N0eWxlXT1cInsgbWluV2lkdGg6IG1vZGVsLnJvd1RpdGxlV2lkdGgsIHdpZHRoOiBtb2RlbC5yb3dUaXRsZVdpZHRoIH1cIiAqbmdJZj1cIm1vZGVsLmhhc1Jvd3NcIj5cbiAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtjb21wb25lbnRdPVwieyBuYW1lOiBtb2RlbC5nZXRSb3dIZWFkZXJXcmFwcGVyQ29tcG9uZW50TmFtZSgkYW55KHJvdykpLCBkYXRhOiB7IGNvbXBvbmVudERhdGE6IG1vZGVsLmdldFJvd0hlYWRlcldyYXBwZXJDb21wb25lbnREYXRhKCRhbnkocm93KSkgfSB9XCI+XG4gICAgICAgICAgICAgICAgPHN2LW5nLXN0cmluZyBbbW9kZWxdPVwicm93LmxvY1RleHRcIj48L3N2LW5nLXN0cmluZz5cbiAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwibW9kZWwuaGFzQ2VsbFRleHRcIj5cbiAgICAgICAgICAgICAgPHRkICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgbW9kZWwudmlzaWJsZUNvbHVtbnNcIlxuICAgICAgICAgICAgICAgIFtjbGFzc109XCJtb2RlbC5nZXRJdGVtQ2xhc3Mocm93LCBjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwib25DaGFuZ2Uocm93LCBjb2x1bW4pXCIgW21vZGVsXT1cIm1vZGVsLmdldENlbGxEaXNwbGF5TG9jVGV4dChyb3cubmFtZSwgY29sdW1uKVwiIHN2LW5nLXN0cmluZz5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFtb2RlbC5oYXNDZWxsVGV4dFwiPlxuICAgICAgICAgICAgICA8dGRcbiAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBtb2RlbC52aXNpYmxlQ29sdW1uczsgaW5kZXggYXMgY29sdW1uSW5kZXg7IHRyYWNrQnk6IHRyYWNrQ29sdW1uQnlGblwiXG4gICAgICAgICAgICAgIFthdHRyLmRhdGEtcmVzcG9uc2l2ZS10aXRsZV09XCJjb2x1bW4ubG9jVGV4dC5yZW5kZXJlZEh0bWxcIlxuICAgICAgICAgICAgICBbY2xhc3NdPVwibW9kZWwuY3NzQ2xhc3Nlcy5jZWxsXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIChtb3VzZWRvd24pPVwibW9kZWwub25Nb3VzZURvd24oKVwiIFtjbGFzc109XCJtb2RlbC5nZXRJdGVtQ2xhc3Mocm93LCBjb2x1bW4pXCI+XG4gICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzXT1cIm1vZGVsLmNzc0NsYXNzZXMuaXRlbVZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgW25hbWVdPVwicm93LmZ1bGxOYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXT1cImNvbHVtbi52YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtjaGVja2VkXT1cInJvdy52YWx1ZSA9PT0gY29sdW1uLnZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cIm1vZGVsLmlzSW5wdXRSZWFkT25seVwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmlkXT1cIm1vZGVsLmlucHV0SWQgKyAnXycgKyByb3cubmFtZSArICdfJyArIGNvbHVtbkluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgKGNoYW5nZSk9XCJvbkNoYW5nZShyb3csIGNvbHVtbilcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXJlcXVpcmVkXT1cIm1vZGVsLmFyaWFSZXF1aXJlZFwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiY29sdW1uLmxvY1RleHQucmVuZGVyZWRIdG1sXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1pbnZhbGlkXT1cIm1vZGVsLmFyaWFJbnZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1kZXNjcmliZWRieV09XCJtb2RlbC5hcmlhRGVzY3JpYmVkQnlcIlxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIFtjbGFzc109XCJtb2RlbC5jc3NDbGFzc2VzLm1hdGVyaWFsRGVjb3JhdG9yXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgKm5nSWY9XCJtb2RlbC5pdGVtU3ZnSWNvblwiIFtjbGFzc109XCJtb2RlbC5jc3NDbGFzc2VzLml0ZW1EZWNvcmF0b3JcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8dXNlIFthdHRyLnhsaW5rOmhyZWZdPVwibW9kZWwuaXRlbVN2Z0ljb25cIj48L3VzZT5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+IFxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gW3Zpc2libGVdPVwibW9kZWwuaXNNb2JpbGVcIiBbY2xhc3NdPVwibW9kZWwuY3NzQ2xhc3Nlcy5jZWxsUmVzcG9uc2l2ZVRpdGxlXCIgW21vZGVsXT1cImNvbHVtbi5sb2NUZXh0XCIgc3Ytbmctc3RyaW5nPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgPC9maWVsZHNldD5cbiAgPC9kaXY+XG48L25nLXRlbXBsYXRlPiJdfQ==